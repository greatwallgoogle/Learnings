# Design-Pattern_ZSX
这一部分主要记录自己学习设计模式的心得体会，并希望给予学习设计模式者一些帮助。<br>
感兴趣的也可以去参考《大话设计模式》，这本书以讲故事的形式很好的诠释了设计模式的意义以及使用。

## 目录

1. 策略模式 ：Strategy  
2. [装饰模式 ：Decorator](#2)  
3. 代理模式 ：Proxy  
4. [工厂方法模式 ：FactoryMethod](#4)  
5. [简单工厂模式 ：FactoryMethod中对比](#5)  
6. [模板方法模式 ：TemplateMethod](#6)  
7. [建造者模式 ：Builder](#7)  

<h2 id="2">二、装饰模式</h2>

 **结构性模式**

 **装饰模式：**
 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

 **应用场景：**
 在一个类中加入了新的字段，新的方法，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为。这种情况下，装饰模式提供了一种很好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要修饰的对象。因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用修饰功能包装对象。
 **需要注意的是：装饰模式中顺序是非常重要的，例如穿衣服的顺序。**


 **优点：**
 将修饰部分与类的主要功能分开，能够简化原有类。

<h2 id="4">四、工厂方法模式</h2>

 **属于类创造型模式**

 **组成部分：**
 抽象工厂(AbstractFactory)：负责声明对外接口。
 具体工厂(ConcreteFactory)：实现抽象工厂中声明的接口，在外部调用，负责生成具体的产品对象，其跟产品时一一对应的。
 抽象产品(AbstractProduct)
 具体产品(Product)

 **优点：**
 外部无需修改代码，每次添加产品时，对应添加具体工厂即可，符合开闭原则。

 **缺点：**
 添加新产品时，需要编写新的产品类和对应的工厂类，系统中类的个数是成对出现的，在一定程度上提高了复杂度。


<h2 id="5">五、简单工厂模式</h2>

 **静态工厂模式，属于类创造型模式**

 **定义：**
 有一个专门的类(工厂类，称为Factory)根据接收到的参数创建指定类型的实例(ConcreteProduct)，返回值具有相同的父类(Product)。

 **组成部分：**
 工厂(Factory),产品(抽象类Product)、具体产品(ConcreteProduct)。其中ConcreteProduct 继承自Product。

 **优点：**
 外部只需要调用指定方法，并给定指定参数即可得到对应的实例。

 **缺点：**
 扩展性低，每增加一个ConcreteProduct，都需要修改工厂类中的创建实例的方法，不符合开闭原则。

 **使用场景：**
 管理的具体产品数量较少时。

<h2 id="6">六、模板方法模式</h2>

  **模板方法模式：**
  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

  **组成部分：**
  AbstractClass 是抽象类，定义并实现了一个模板方法和若干个抽象方法，这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象方法中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。


  **ConcreteClass子类：**
  实现父类所定义的一个或多个抽象方法。一个AbstractClass可以有多个子类，不同的子类可以对抽象方法进行不同的实现，从而使得顶级逻辑的实现各不相同。


  **优点：**
  把不变的行为移到父类，去除子类中的重复代码。

  **适用情况：**
  当不变的和可变的行为在子类方法中混合在一起的时候，不变的行为就会在不同的子类中重复出现，这种情况下应该使用模板方法模式来设计。

<h2 id="7">七、建造者模式</h2>

 **创建型模式**
 **定义：**
 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

 **组成部分：**
 指挥类Director：两个作用，1.用于控制创建顺序。2.隔离用户与创建过程的关联。
 抽象类Builder：为创建一个产品对象的各个部件指定抽象接口。
 具体构建类ConcreteBuilder：实现接口中的抽象方法，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
 产品Product：被构建的复杂对象，包含多个组成部件。

 **适用场景：**
 主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。（比如建造小人的过程）

 **好处：**
 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都是相对独立，而与其他的具体建造者无关，因此可以很方便的替换或者增加新的具体建造者，符合“开闭原则”。

 **缺点：**

 * 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间差异性很大，则不适合使用该模式。
 * 如果产品的内部变化复杂，可能导致需要定义很多具体建造者类来实现这种变化，导致系统变化很庞大。

 （有点疑问：如果需要修改建造过程该怎么办？）

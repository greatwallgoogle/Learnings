---
--- Generated by jianxi(mabeijianxi@gmail.com)
--- Created by jianxi.
--- DateTime: 2018/7/9 上午10:14
---
require("comment_const")
require("bridge.lua_call_native")

commentUtils = commentUtils or {}
local tag = "commentUtils"

function commentUtils.simpleCopyTable(srcTable)
    local newTable = {}

    for key, value in pairs(srcTable) do
        newTable[key] = value
    end

    return newTable
end

function commentUtils.removeTabKeys(srcTable, deleteList)
    commentUtils.printLog("animUtils", "removeTabKeys" .. #deleteList)
    if (#deleteList <= 0) then
        return srcTable
    end

    local newTable = {}
    for key, value in pairs(srcTable) do

        local needDelete = false
        for deleteKey, deleteValue in pairs(deleteList) do
            if deleteValue == key then
                needDelete = true
                break
            end
        end
        if (not needDelete) then
            newTable[key] = value
        end
    end

    return newTable
end

function commentUtils.tableMaxN (srcTable)
    local maxn = 0
    if srcTable ~= nil then
        for k, v in pairs(srcTable) do
            maxn = maxn + 1
        end
    end
    return maxn
end

function commentUtils.split( str, reps )
    local resultStrList = {}
    string.gsub(str, '[^' .. reps .. ']+', function( w )
        table.insert(resultStrList, w)
    end)
    return resultStrList
end

function commentUtils.maxRectangle2D(point1, point2, point3, point4)
    local maxY = commentUtils.findMax(point1.y, point2.y, point3.y, point4.y)
    local minY = commentUtils.findMin(point1.y, point2.y, point3.y, point4.y)

    local minX = commentUtils.findMin(point1.x, point2.x, point3.x, point4.x)
    local maxX = commentUtils.findMax(point1.x, point2.x, point3.x, point4.x)

    local newPoint1 = XVECTOR2(minX, maxY)
    local newPoint2 = XVECTOR2(maxX, maxY)
    local newPoint3 = XVECTOR2(maxX, minY)
    local newPoint4 = XVECTOR2(minX, minY)

    return newPoint1, newPoint2, newPoint3, newPoint4
end

function commentUtils.findMax( ... )
    local list = { ... }
    local max = list[1]
    for k, v in pairs(list) do
        if max < v then
            max = v
        end
    end
    return max
end

function commentUtils.findMin( ... )
    local list = { ... }
    local min = list[1]
    for k, v in pairs(list) do
        if min > v then
            min = v
        end
    end
    return min
end

function fullPointY(value, ...)
    local points = { ... }
    for k, v in pairs(points) do
        v.y = value
    end
end

function fullPointX(value, ...)
    local points = { ... }
    for k, v in pairs(points) do
        v.x = value
    end
end

function commentUtils.normalRectangle(point1, point2, point3, point4)
    local diffX = math.abs(point1.x - point2.x)
    local diffY = math.abs(point1.y - point4.y)

    if (diffX > diffY) then
        local absDiff = diffX - diffY
        point4.y = point4.y - absDiff / 2
        point1.y = point1.y + absDiff / 2

        point3.y = point3.y - absDiff / 2
        point2.y = point2.y + absDiff / 2
    else
        local absDiff = diffY - diffX
        point4.x = point4.x - absDiff / 2
        point1.x = point1.x - absDiff / 2

        point3.x = point3.x + absDiff / 2
        point2.x = point2.x + absDiff / 2
    end
end

function commentUtils.maxRectangle3D(point1, point2, point3, point4, point5, point6, point7, point8)

    local maxY = commentUtils.findMax(point1.y, point2.y, point3.y, point4.y, point5.y, point6.y, point7.y, point8.y)
    local minY = commentUtils.findMin(point1.y, point2.y, point3.y, point4.y, point5.y, point6.y, point7.y, point8.y)

    local minX = commentUtils.findMin(point1.x, point2.x, point3.x, point4.x, point5.x, point6.x, point7.x, point8.x)
    local maxX = commentUtils.findMax(point1.x, point2.x, point3.x, point4.x, point5.x, point6.x, point7.x, point8.x)

    local newPoint1 = XVECTOR2(minX, maxY)
    local newPoint2 = XVECTOR2(maxX, maxY)
    local newPoint3 = XVECTOR2(maxX, minY)
    local newPoint4 = XVECTOR2(minX, minY)

    return newPoint1, newPoint2, newPoint3, newPoint4

end

function commentUtils.printPointV3(tag, point)
    commentUtils.printLog(tag, "point v3 x: " .. point.x)
    commentUtils.printLog(tag, "point v3 y: " .. point.y)
    commentUtils.printLog(tag, "point v3 z: " .. point.z)
end

function commentUtils.printPointV2(tag, point)
    commentUtils.printLog(tag, "point v2 x: " .. point.x)
    commentUtils.printLog(tag, "point v2 y: " .. point.y)
end

function commentUtils.getModelRelativeDir ()
    return commentConst.PetModelRootFirstDirName .. "/" .. luaCallNative.getPetModelDirName()
end

function commentUtils.isInScreen(screenWidth, screenHeight, left, top, right, bottom)
    if (left >= 0
            and top >= 0
            and right <= screenWidth
            and bottom <= screenHeight) then
        return true
    else
        return false
    end
end

function commentUtils.getPreciseDecimal(nNum, n)
    if type(nNum) ~= "number" then
        return nNum;
    end

    local values = commentUtils.split(tostring(nNum), "e")

    nNum = tonumber(values[1])

    n = n or 0;
    n = math.floor(n)
    local fmt = '%.' .. n .. 'f'
    local nRet = tonumber(string.format(fmt, nNum))

    return nRet;
end

function commentUtils.get2DVector(vector1, vector2)
    local theata = math.atan2(vector1.y, vector1.x) - math.atan2(vector2.y, vector2.x)

    if (theata > math.pi) then
        theata = theata - 2 * math.pi
    end
    if (theata < -math.pi) then
        theata = theata + 2 * math.pi
    end
    return theata
end

function commentUtils.evaluateValue(fraction, startValue, endValue)
    return startValue + fraction * (endValue - startValue);
end

function commentUtils.getLineOnePointY(point1, point2, x)
    if ((point2.x - point1.x) ~= 0) then
        local y = (((x - point1.x) * (point2.y - point1.y)) / (point2.x - point1.x)) + point1.y
        return y
    else
        return commentConst.ERROR
    end
end

function commentUtils.rotation3DVector4Y(fAngle, targetVector)

    return XMATRIX3(math.cos(fAngle), 0, math.sin(fAngle),
            0, 1, 0,
            -math.sin(fAngle), 0, math.cos(fAngle)
    ) * targetVector
end

function commentUtils.rotation3DVector4X(fAngle, targetVector)

    return XMATRIX3(1, 0, 0,
            0, math.cos(fAngle), -math.sin(fAngle),
            0, math.sin(fAngle), math.cos(fAngle)
    ) * targetVector
end

function commentUtils.intersect(srcLeft, srcTop, srcRight, scrBottom, desLeft, desTop, desRight, desBottom)
    if (srcLeft < desRight and desLeft < srcRight and srcTop < desBottom and desTop < scrBottom) then
        return true;
    end
    return false;
end

function commentUtils.intersect(srcLeft, srcTop, srcRight, scrBottom, desLeft, desTop, desRight, desBottom)
    if (srcLeft < desRight and desLeft < srcRight and srcTop < desBottom and desTop < scrBottom) then
        return true;
    end
    return false;
end

function commentConst.pointIsInScreen(targetPoint)
    local targetPoint2D = xe.Director:GetInstance():GetWindow():GetViewport():GetXViewport():TransformWorldToScreen(targetPoint)
    local window = xe.Director:GetInstance():GetWindow()
    local screenWidth = window:GetWidth()
    local screenHeight = window:GetHeight()

    if targetPoint2D.x >= 0 and targetPoint2D.x <= screenWidth and targetPoint2D.y >= 0 and targetPoint2D.y <= screenHeight then
        return true
    else
        return false
    end

end

function commentUtils.is2DPointInRect(x, y, mLBPoint, mLTPoint, mRTPoint, mRBPoint)

    local A = mLBPoint;
    local B = mLTPoint;
    local C = mRTPoint;
    local D = mRBPoint;

    local a = (B.x - A.x) * (y - A.y) - (B.y - A.y) * (x - A.x);
    local b = (C.x - B.x) * (y - B.y) - (C.y - B.y) * (x - B.x);
    local c = (D.x - C.x) * (y - C.y) - (D.y - C.y) * (x - C.x);
    local d = (A.x - D.x) * (y - D.y) - (A.y - D.y) * (x - D.x);
    if ((a > 0 and b > 0 and c > 0 and d > 0) or (a < 0 and b < 0 and c < 0 and d < 0)) then
        return true;
    end
    return false;

end

commentUtils.rectList = commentUtils.rectList or {}

function commentUtils.drawOneRectAndCancelOtherDrawRect(lTPoint, rTPoint, rBPoint, lBPoint, color)

    for k, v in pairs(commentUtils.rectList) do
        xe.Scheduler:unschedule(v)
    end

    local drawRectTask = xe.Scheduler:schedule(function()
        g_pXCanvasBase:RenderLine(
                XVECTOR3(lTPoint.x, lTPoint.y, lTPoint.z),
                XVECTOR3(rTPoint.x, rTPoint.y, rTPoint.z),
                color,
                true
        )
        g_pXCanvasBase:RenderLine(
                XVECTOR3(rTPoint.x, rTPoint.y, rTPoint.z),
                XVECTOR3(rBPoint.x, rBPoint.y, rBPoint.z),
                color,
                true
        )
        g_pXCanvasBase:RenderLine(
                XVECTOR3(rBPoint.x, rBPoint.y, rBPoint.z),
                XVECTOR3(lBPoint.x, lBPoint.y, lBPoint.z),
                color,
                true
        )
        g_pXCanvasBase:RenderLine(
                XVECTOR3(lBPoint.x, lBPoint.y, lBPoint.z),
                XVECTOR3(lTPoint.x, lTPoint.y, lTPoint.z),
                color,
                true
        )
    end, 0.01, -1, 0)
    commentUtils.rectList[#commentUtils.rectList + 1] = drawRectTask
end

function commentUtils.drawOneRectAndCancelDrawRect(lTPoint, rTPoint, rBPoint, lBPoint, color)

    for k, v in pairs(commentUtils.rectList) do
        xe.Scheduler:unschedule(v)
    end

    local drawRectTask = xe.Scheduler:schedule(function()
        g_pXCanvasBase:RenderLine(
                XVECTOR3(lTPoint.x, lTPoint.y, lTPoint.z),
                XVECTOR3(rTPoint.x, rTPoint.y, rTPoint.z),
                color,
                true
        )
        g_pXCanvasBase:RenderLine(
                XVECTOR3(rTPoint.x, rTPoint.y, rTPoint.z),
                XVECTOR3(rBPoint.x, rBPoint.y, rBPoint.z),
                color,
                true
        )
        g_pXCanvasBase:RenderLine(
                XVECTOR3(rBPoint.x, rBPoint.y, rBPoint.z),
                XVECTOR3(lBPoint.x, lBPoint.y, lBPoint.z),
                color,
                true
        )
        g_pXCanvasBase:RenderLine(
                XVECTOR3(lBPoint.x, lBPoint.y, lBPoint.z),
                XVECTOR3(lTPoint.x, lTPoint.y, lTPoint.z),
                color,
                true
        )
    end, 0.01, -1, 0)
    commentUtils.rectList[#commentUtils.rectList + 1] = drawRectTask
end

function commentUtils:boolean2NumStr(b)
    if b then
        return '1'
    else
        return '0'
    end

end

function commentUtils.printLog(tag, msg)
    if isDebug then
        printLog(tag, msg)
    end
end

return commentUtils